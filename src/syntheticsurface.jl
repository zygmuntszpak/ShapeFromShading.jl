@doc raw"""
```
img = generate_surface(shape::AbstractSyntheticShape, albedo::Real = 1.0, illumination_direction::Vector{T} where T <: Real = [0.0, 0.0, 1.0]; img_size::Int=151, noise::Real = 0, relative_noise::Bool = true)
```
Creates a synthetic image of a given shape with the given illumination properties.
# Output
Returns a grayscale image with dimensions `img_size` in both axes.
# Details
Uses the passed properties to calculate the partial differentials of the shape
reflectance and uses these to generate a synthetic image of the shape to be used
as a consistent test image for SFS testing.
# Arguments
The function arguments are described in more detail below.
## `shape`
A `AbstractSyntheticShape` that specifies the type of shape to be generated. Available
shapes are; SynthSphere, Prism, Ripple, Ripple2, Cake, Cake2, SynthVase, Tent, Dem,
SynthGaussian and SuperGaussian. Each has a parameter `radius`, a `Real` that
specifies the radius of the desired shape or its scale within the image. This can
acts as either an actual radius (such as for `SynthSphere`) or rather as a scale
factor (such as for `Ripple`). If left unspecified a default value is used for each.
## `albedo`
A `Real` that specifies the albedo (amount of light reflected) of the image. If
left unspecified a default value of 1.0 is used.
## `illumination_direction`
A `Vector{T} where T <: Real` that specifies the tilt value to be used by the
algorithm. The `illumination_direction` should be a vector of the form [x,y,z]
where x,y,z are in the range [0,1]. If left unspecified a default value of
[0.0,0.0,1.0] is used.
## `img_size`
A `Int` that specifies the dimentions of the final image should be. Defults to 151.
## `noise`
A `Real` that specifies the standard deviation of noise to be added to the image.
Defults to 0.0.
## `relative_noise`
A `Bool` that specifies if the noise added to the image should be relative to the
gradient of the object displayed in the image at that point.
# Example
Compute the heightmap for a synthetic image generated by `generate_surface`.
```julia
using Images, ShapeFromShading

#generate synthetic image
img = generate_surface(SynthSphere(50), 1.0, [0.5,0.1,0.7])
```
# Reference
1. S. Elhabian, "Hands on Shape from Shading", Computer Vision and Image Processing, 2008.
"""
function generate_surface(shape::AbstractSyntheticShape, albedo::Real = 1.0, illumination_direction::Vector{T} where T <: Real = [0.0, 0.0, 1.0]; img_size::Int=151, noise::Real = 0, relative_noise::Bool = true)
    I = illumination_direction./norm(illumination_direction)
    ρ = albedo
    R = zeros(Float64, img_size, img_size)
    x,y = setup_xy(img_size)
    p,q = synthetic_gradient(shape, img_size=img_size, noise=noise, relative_noise=relative_noise)
    for i in CartesianIndices(R)
        R[i] = (ρ * (-I[1] * p[i] - I[2] * q[i] + I[3])) / sqrt(1 + p[i]^2 + q[i]^2)
    end
    E = max.(0.0, Float64.(R))

    #convert to img and return
    img = Gray.(E)
    return img
end

# Generates image from given gradients
function generate_surface(p, q, albedo::Real = 0.5, illumination_direction::Vector{T} where T <: Real = [0, 0, 1]; img_size::Int=151, noise::Real = 0, relative_noise::Bool = true)
    I = illumination_direction./norm(illumination_direction)
    ρ = albedo
    R = zeros(Float64, img_size, img_size)
    x,y = setup_xy(img_size)
    for i in CartesianIndices(R)
        R[i] = (ρ * (-I[1] * p[i] - I[2] * q[i] + I[3])) / sqrt(1 + p[i]^2 + q[i]^2)
    end
    E = max.(0.0, Float64.(R))

    #convert to img and return
    img = Gray.(E)
    return img
end

# Generates image, gradients and ground truth for a shape
function generate_surface_data(shape::AbstractSyntheticShape, albedo::Real = 0.5, illumination_direction::Vector{T} where T <: Real = [0, 0, 1]; img_size::Int=151, noise::Real = 0, relative_noise::Bool = true)
    img = generate_surface(shape, albedo, illumination_direction, img_size = img_size, noise = noise, relative_noise = relative_noise)
    p,q = synthetic_gradient(shape, img_size = img_size, noise = noise, relative_noise = relative_noise)
    Z = ground_truth(shape, img_size = img_size)
    return img, p, q, Z
end

# Generate three sythetic images of a shape
function generate_photometric(shape::AbstractSyntheticShape, albedo::Real = 0.5, I₁::Vector{T} where T <: Real = [0, 0, 1], I₂::Vector{T} where T <: Real = [0.5, 0, 1], I₃::Vector{T} where T <: Real = [0, 0.5, 1]; radius::Real = 50, img_size::Int=151, noise::Real = 0, relative_noise::Bool = false)
    img1 = generate_surface(shape, albedo, I₁, img_size = img_size, noise = noise, relative_noise = relative_noise)
    img2 = generate_surface(shape, albedo, I₂, img_size = img_size, noise = noise, relative_noise = relative_noise)
    img3 = generate_surface(shape, albedo, I₃, img_size = img_size, noise = noise, relative_noise = relative_noise)
    return img1, img2, img3
end

# Generates synthetic gradients for a shape
function synthetic_gradient(shape::AbstractSyntheticShape; img_size::Int=151, noise::Real = 0, relative_noise::Bool = true)
    od = OnceDifferentiable(x -> shape(x), [0.0,0.0]; autodiff = :forward)
    p = zeros(Float64, img_size, img_size)
    q = zeros(Float64, img_size, img_size)
    x,y = setup_xy(img_size)
    for i in CartesianIndices(x)
        pq = [0.0,0.0]
        od.df(pq,([x[i],y[i]]))
        p[i], q[i] = pq
        if isnan(p[i])
            p[i] = 0.0
        end
        if isnan(q[i])
            q[i] = 0.0
        end
    end
    valP = maximum(abs.(p))
    valQ = maximum(abs.(q))
    for i in CartesianIndices(x)
        if relative_noise == false
            p[i] += rand(Normal(0, noise))
            q[i] += rand(Normal(0, noise))
        else
            p[i] += rand(Normal(0, noise*valP))
            q[i] += rand(Normal(0, noise*valQ))
        end
    end
    return p,q
end

# Generates gorund truth for a shape
function ground_truth(shape::AbstractSyntheticShape;img_size::Int=151)
    Z = zeros(Float64, img_size, img_size)
    x,y = setup_xy(img_size)
    for i in CartesianIndices(Z)
        Z[i] = shape([x[i],y[i]])
    end
    return Z
end

# Cake like shape
function (shape::Cake)(x::AbstractArray)
    r = shape.radius
    z = 75 * sin(π*(x[1]^2 + x[2]^2) / (71 * r))
    if z < 0.0
        z = 0.0
    end
    if x[1]^2 + x[2]^2 > r^2
        z = 0.0
    end
    return z
end

# Cake like shape version 2
function (shape::Cake2)(x::AbstractArray)
    r = shape.radius
    xy = sqrt(x[1]^2 + x[2]^2)
    z = -(xy + 60)*(xy + 20)*(xy - 20)*(xy - 60) / 60000
    if z < 0.0
        z = 0.0
    elseif z > 30.0
        z = 30.0
    end
    return z
end

function g(x,y)
    return 3 * (1 - x)^2 * exp(-x^2 - (y + 1)^2) - 10 * (x / 5 - x^3 - y^5) * exp(-x^2 - y^2) - (1/3) * exp(-(x + 1)^2 - y^2)
end

# DEM
function (shape::Dem)(x::AbstractArray)
    r = shape.radius
    x = x ./ r .* 6.4
    x = x ./ 1.6
    z = g(x[1], x[2]) *r/6.4
    return z
end

# Prism like shape
function (shape::Prism)(x::AbstractArray)
    r = shape.radius
    z = 0.0
    if abs(x[1]) <= r/2 && abs(x[2]) <= r/2
        z = x[1]
    end
    return z
end

# Ripple
function (shape::Ripple)(x::AbstractArray)
    r = shape.radius
    z = 25*cos(sqrt(x[1]^2 + x[2]^2) / r)
    return z
end

# Ripple with decayed edges
function (shape::Ripple2)(x::AbstractArray)
    r = shape.radius
    z = 25 * cos(sqrt(x[1]^2 + x[2]^2)/r) * 62.5 * (1/sqrt(pi * 1250)) * exp(-((x[1]^2 + x[2]^2) / 1250))
    return z
end

# Gaussian to a higher power
function (shape::SuperGaussian)(x::AbstractArray)
    r = shape.radius
    x = x ./ r .* 4
    P = 2
    z = exp(-((x[1]^2)/2+(x[2]^2)/2)^P)*r/4
    return z
end

# Gaussian
function (shape::SynthGaussian)(x::AbstractArray)
    r = shape.radius
    x = x ./ r .* 4
    z = exp(-((x[1]^2)/2+(x[2]^2)/2)) * r/4
    return z
end

# Sphere
function (shape::SynthSphere)(x::AbstractArray)
    r = shape.radius
    if x[1]^2 + x[2]^2 < r^2
        z = sqrt(r^2-(x[1]^2 + x[2]^2))
    else
        z = 0.0
    end
    return z
end

function f(x)
    return -138.24 * x^6 + 92.16 * x^5 + 84.48 * x^4 - 48.64 * x^3 - 17.60 * x^2 + 6.4 * x + 3.2
end

# Vase
function (shape::SynthVase)(x::AbstractArray)
    r = shape.radius
    x = x./r .* 6.4
    if f(x[1]/12.8)^2 >= x[2]^2
        z = sqrt(f(x[1]/12.8)^2 - x[2]^2)*r/6.4
    else
        z = 0.0
    end
    return z
end

# Canadian tent
function (shape::Tent)(x::AbstractArray)
    r = shape.radius
    x = x ./ r .* 6.4
    if abs(x[1]) <= 5.12 && abs(x[2]) <= 5.12
        z = min(-2 * abs(x[1]) + 10.24, -abs(x[2]) + 5.12)*r/6.4
    else
        z = 0.0
    end
    return z
end

# Allows for interactive generation of images
function create_image()
    slider1 = widget(-1:0.01:1)
    slider2 = widget(-1:0.01:1)
    slider3 = widget(0.01:0.01:1)
    slider4 = widget(1:100, value = 5)
    sizeVal = spinbox(1:5000, label="Image size:", value = 151)
    r = slider4[]
    I = [slider1[],slider2[],slider3[]]
    imgSize = sizeVal[]
    img = generate_surface(SynthSphere(), 1, I, radius = 5)
    dis = Observable(img)
    shape = SynthSphere()
    shapeOptions = dropdown(OrderedDict("Sphere"=>SynthSphere(), "Ripple"=>Ripple(), "Ripple2"=>Ripple2(), "Cake"=>Cake(), "Cake2"=>Cake2(), "Vase"=>SynthVase(), "Dem"=>Dem(), "Tent"=>Tent(), "Gaussian"=>SynthGaussian(), "Super Gaussian"=>SuperGaussian()))
    ui = Interact.vbox(slider1,slider2,slider3, dis, Interact.hbox(shapeOptions, sizeVal),slider4)
    w = Window()
    body!(w,ui)

    on(slider1) do val
        I = [slider1[],slider2[],slider3[]]
        img = generate_surface(shape, 1.0, I, radius = r, img_size = imgSize)
        dis[] = img
    end

    on(slider2) do val
        I = [slider1[],slider2[],slider3[]]
        img = generate_surface(shape, 1.0, I, radius = r, img_size = imgSize)
        dis[] = img
    end

    on(slider3) do val
        I = [slider1[],slider2[],slider3[]]
        img = generate_surface(shape, 1.0, I, radius = r, img_size = imgSize)
        dis[] = img
    end

    on(slider4) do val
        r = slider4[]
        img = generate_surface(shape, 1.0, I, radius = r, img_size = imgSize)
        dis[] = img
    end

    on(shapeOptions) do val
        shape = shapeOptions[]
        img = generate_surface(shape, 1.0, I, radius = r, img_size = imgSize)
        dis[] = img
    end

    on(sizeVal) do val
        imgSize = sizeVal[]
        img = generate_surface(shape, 1.0, I, radius = r, img_size = imgSize)
        dis[] = img
    end
end
